---
title: "lmmur_14"
author: "Randy"
date: "9/19/2021"
output: html_document
editor_options: 
  markdown: 
    wrap: 72
---

```{r}
library("tidyverse")
library("knitr")
library("tinytex")
library("bookdown")
library("nlme")
library("nlmeU")
```

# Chapter 14 Fitting Linear Mixed-Effects Models: The `lme()` Function

`nlme`, `lme4`, and `MCMCglmm`

## 14.2 Representation of a Positive-Definite Matrix: The pdMat Class

### 14.2.1 Constructor Functions for the pdMat Class

`pdIdent`: a multiple of identity `pdDiag`: a diagonal matrix
`pdCompSymm`: compound symmetry `pdLogChol`: a general positive-definite
matrix using the log-Cholesky parameterization `pdSymm`: a general
positive-definite matrix with a parameterization based on SVD
`pdNatural`: a general-positive-definite matrix with the natural
parameterization, i.e., in terms of standard deviations and correlations
`pdBlocked`: a blocked-diagonal matrix, with blocks defined by
structures/classes defined above

Note that the created object inherits also from the `pdMat` class.

The `pdMat` constructors are primarily used in the specification of the
random-effects structure of an LMM, with the help of the random argument
of the model-fitting function `lme()`.

#### 14.2.1.1 Arguments of the Constructor Functions

The arguments of the pdMat constructor functions are **value**,
**form**, **nam**, and **data**. important arguements are the **value**
and **form** arguments.

Arguments **data** and **nam** are merely used to assign names to the
rows and columns of a positive-definite matrix. As such, they are less
important, so we do not describe them.

-   **form** is simply an optional one-sided formula.

When used together with the **data** argument, the **formula** is
evaluated and, subsequently, the appropriate names are assigned to the
rows/columns of the matrix represented by the object.

By default, the value of the **form** argument is NULL. If the **value**
argument contains a one-sided formula, the argument **form** is ignored.

-   **value** is the main argument of a `pdMat` constructor function.

it can be used to specify the components of `pdMat` objects, defined by
the arguments described above.

The main role of this argument is to assign coefficients to `pdMat`
objects by supplying a positive-definite matrix or a numeric vector.
Other possible values of the **value** argument include: a `pdMatclass`
object, a one-sided linear formula, or a vector of character strings.

By default, its value is `numeric(0)`, which results in **an
uninitialized object**.

The constructor functions `pdCompSymm()` and `pdSymm()` to create
objects of class `pdCompSymm` and `pdSymm`, respectively, which inherit
from the `pdMat` class. R14.1 R syntax: Creating objects inheriting from
the pdMat class

```{r "R14.1"}
## Standard classes of positive-definite matrices 
## (pdMat) structures available in the nlme package.
?pdClasses
?pdSymm
?pdMat 
## This function gives an alternative way of constructing an object inheriting from the pdMat class named in pdClass, or from data.class(object) if object inherits from pdMat, and is mostly used internally in other functions. See the documentation on the principal constructor function, generally with the same name as the pdMat class of object.

## (a) Uninitialized object of class pdCompSymm
## applies the value in the form of a one-sided formula
## it does not assign any numeric values 
## This object is merely an empty compound-symmetry matrix
(pdCS0 <- pdCompSymm(~agex))
# str(pdCS0) ## Error in pdMatrix.pdCompSymm(x) : 
             ## cannot extract the matrix from an uninitialized "pdCompSymm" object
# Not initialize
# did not assign any value to the matrix yet
isInitialized(pdCS0) 
# pdCS0 ## Uninitialized positive definite matrix structure of class pdCompSymm.

## (b) Initialized object of class pdSymm
## pdSymm matrix
mtxUN <- matrix(c(4, 1, 1, 9), nrow = 2) 
## the object mtxUN is a positive-definite, 2×2 matrix, 
## while dt1 is an auxiliary data frame with 
## a single numeric variable agex with four observations.
## The pdSymm() function uses the matrix mtxUN as the value argument. 
dt1 <- data.frame(agex = c(15, 45, 71, 82)) 
## object pdSm can be interpreted as the variance–covariance matrix
## of a vector of random effects generated by the formula.
## Given that the variable agex is numeric (continuous), 
## the formula implies the use of random intercepts and 
## of random slopes (for agex). 
## Hence, the use of the names (Intercept) and agex 
## for the rows and columns of the matrix
(pdSm <- pdSymm(mtxUN, ~agex, data = dt1))
isInitialized(pdSm) # Initialized

## (c) Initialized object of class pdCompSymm
mtxCS <- matrix(4 * diag(3) + 1, nrow = 3) # CompSymm matrix
dt2 <- data.frame(agef=c("Y", "M", "O", "O")) # Factor age
## The auxiliary object dt2 is a data frame with a single-variable agef, 
## which is a factor with three levels and four observations. 
## The pdCompSymm() constructor function uses the object mtxCS as the value argument. 
(pdCSf <- pdCompSymm(mtxCS, ~-1 + agef, data = dt2))
(pdCSf2 <- pdCompSymm(mtxCS, ~agef, data = dt2))
## -1 indicates the repression of intercept
```

The resulting object **pdCsf** of class `pdCompSymm`, which represents a
compound-symmetry matrix, is initialized.

Note that its row and column names are defined by the levels of the
factor `agef`.

Thus, the formula implies the use of three random effects, associated
with the levels of the factor. Hence, the use of the factor-level names
for the rows and columns of **pdCSf**.

Note that the names are obtained by referring to the data frame **dt2**,
which was provided in the argument data. Had the formula been changed
to, e.g., `~agef`, it would have implied the use of an intercept, and
the name of the first row and column of the object **pdSm** would have
been changed to (Intercept).

The names of the remaining two rows and columns would remain unchanged.

When specifying an LMM, it is sufficient to work with uninitialized
pdMat objects.

Initialized objects, i.e., objects with defined, known numerical values
can be useful if initial values for coefficients of a positive-definite
matrix need to be specified for a model-fitting routine.

## 14.2.2 Inspecting and Modifying Objects of Class pdMat

```{r "R14.2"}
methods(class = "pdMat")
methods(class = "varFunc")
methods(class = "corCompSymm")
methods(class = "lme")
methods(class = "gls")

## (a) Extracting information from the object pdSm of class pdSymm
summary(pdSm) # Summary
# pdSm
formula(pdSm) # Formula
Names(pdSm) # Row/col names
```

```{r}
(Dmtx <- as.matrix(pdSm)) # D matrix
Dim(pdSm) # Dimensions of D
## The function logDet() prints out the value of 
## the logarithm of the determinant of the Cholesky factor of 
## the positive-definite matrix represented by the pdSymm-class object.
logDet(pdSm) # log|D1/2|

VarCorr(pdSm) # Variances, correlation coefficients
corMatrix(pdSm) # Corr(D)

## (b) Extracting information from the object pdCSf of class pdCompSymm
Names(pdCSf) # Row/col names
as.matrix(pdCSf) # D matrix
logDet(pdCSf)
```

```{r "R14.3"}
## (a) Extracting coefficients from the object pdSm of class pdSymm
## Constrained coefficients
coef(pdSm, unconstrained = FALSE)
## Unconstrained coefficients
coef(pdSm) 

## (b) Extracting coefficients from the object pdCSf of class pdCompSymm
# Constrained coefficients
coef(pdCSf, unconstrained = FALSE) 
# Unconstrained coefficients
coef(pdCSf) 

pdCSf

log(5)/2 # First coefficient verified
rho <- 0.2 # %
nc <- 3 # No. of columns

## Modified Fisher's z: (10.35)
aux <- (rho + 1/(nc - 1))/(1 - rho)
log(aux) # Second coefficient verified
```

-   extract coefficients from the object pdSm.

as an object of class pdSymm, i.e., it represents a positive-definite
matrix of a general form.

-   by specifying the argument `unconstrained=FALSE`, we obtain the
    upper-triangular elements of the matrix.

-   the unconstrained coefficients, which result from applying the
    matrix-logarithm transformation (Sect. 13.5.4).

-   first one is the logarithm of the standard deviation

-   second one is the modified Fisher's z-transform (10.35) of the
    correlation coefficient.

-   the computations of the values of the two unconstrained coefficients
    are verified at the end

#### different parameterizations of a general positive-definite matrix, represented by different `pdMat` classes.

```{r}
## (a) The matrix-logarithm parameterization – pdSymm class
mtxUN
pdSm0 <- pdSymm(mtxUN)
coef(pdSm0) # Unconstrained \theta_D

Dmtx <- pdMatrix(pdSm0) # Matrix D
## Cholesky factor: D = U'U
CholD <- chol(Dmtx) 
## SVD of U: (13.46)
vd <- svd(CholD, nu = 0) 
## (13.47) the logarithm of the matrix
vd$v %*% (log(vd$d) * t(vd$v)) 


## (b) The log-Cholesky parameterization – pdLogChol class
pdLCh <- pdLogChol(mtxUN)
coef(pdLCh) # Unconstrained coefficients \theta_D

LChD <- CholD # U
diag(LChD) <- log(diag(LChD)) # diag(U) log-transformed
LChD

## (c) The “natural” parameterization – pdNatural class
pdNat <- pdNatural(mtxUN)
coef(pdNat) # Unconstrained \theta_D

log(sqrt(diag(Dmtx))) # log(SDs)

corD <- cov2cor(Dmtx) # Corr(D)
rho <- corD[upper.tri(corD)] # %ij (for i < j)
log((1+rho)/(1-rho)) # Fisher's z: (10.33)
```

-   explicitly the link between the unconstrained coefficients of an
    object of class pdSymm and the logarithm of a positive-definite
    matrix.

-   the upper-triangular elements of the resulting matrix-logarithm
    correspond to the unconstrained coefficients obtained by applying
    the `coef()` method to the object **pdSm0**.

-   it is worth mentioning that the matrix logarithm of the matrix
    **Dmtx** can be obtained by simply doubling the elements of the
    matrix logarithm of the matrix **CholD**.

-   the coefficients are obtained from the elements of th Cholesky
    factor matrix, but with the diagonal elements replaced by their
    logarithms.

-   to illustrate the computation of the coefficients explicitly, we
    reuse the matrix CholD, created in Panel R14.4a.

-   replace the diagonal elements of the resulting matrix, LChD, by
    their logarithms.

-   the upper-triangular elements of the so-obtained matrix correspond
    to the unconstrained coefficients of the **pdLogChol**
    representation.

-   we apply the `pdNatural()` constructor function.

-   the representation is based on the use of standard deviations and
    correlation coefficients, which correspond to **mtxUN**.

-   the coefficients are obtained by logtransforming the standard
    deviations and by applying Fisher's z-transform to the correlation
    coefficients (Sect. 13.5.4).

-   the transformations are shown explicitly in this subpanel.

## 14.3 Random-Effects Structure Representation: The `reStruct` class

### 14.3.1 Constructor Function for the reStruct Class

`reStruct()` is a constructor function for an object of class
`reStruct`.

The arguments of the function include `object`, `pdClass`, `REML`,
`data`, `x`, `sigma`, `reEstimates`, and `verbose`. Description of these
arguments can be obtained by issuing the command ?reStruct.

```{r}
## This function is a constructor for the reStruct class, 
## representing a random effects structure and consisting of a list of pdMat objects, 
## plus a settings attribute containing information for 
## the optimization algorithm used to fit the associated mixed-effects model.
?reStruct
```

-   `object` is the most important one.

the syntax is very similar to that of the random argument of the `lme()`
function, which is the key function to fit LMMs in the package **nlme**.

-   the syntax of the `lme()` function will be described in Sect. 14.5.

-   essential role of the `object` argument is to pass the information
    necessary for the specification of the random-effects structure.

-   the argument is used to provide the information about the model
    hierarchy and about the formulae associated with the `pdMat`
    objects, which are later used to create the **random design
    matrices**.

-   the argument can be used to specify the information about the
    structure of the matrix (or matrices) D, including the values of
    their elements.

![](figure/lmmur_t_14_1.png)

-   four forms of the syntax that can be used for the argument object of
    the `reStruct()` constructor function.

-   assume that the two levels of grouping are defined by grouping
    factors g1 and g2.

-   variables z1 and z2 are used as random-effects covariates by g1 and
    g2, respectively.

-   all forms of the syntax, shown in Table 14.1, allow a direct
    specification of the hierarchical structure of the model using
    grouping factors, such as g1 and g2 in our example.

-   they differ in the flexibility of specifying other components of the
    random-effects structure.

-   the use of the variables z1 and z2 to introduce random effects
    associated with covariates.

![](figure/lmmur_t_14_2.png)

part (a) of the table, we present an example of syntax for a
single-level LMM, with grouping defined by the factor g1 and a single
random-effects covariate z1.

part (b) of the table, we show the four forms of the syntax for the same
setting as in Table 14.1, i.e., for a two-level LMM.

-   

    (a) is the most flexible

    -   essentially allows incorporating the information about all
        components of the random-effects structure, which are supported
        by the `lme()` function.

    -   for a two-level LMM (see (13.5)), it allows specifying different
        structures of the D matrices at different levels of the model
        hierarchy.

    -   in Table 14.1, the different matrix structures are represented
        by objects of classes `pdSymm` and `pdDiag`.

    -   the matrix D1 assumed to have a general form, while the matrix
        D2 is assumed to be diagonal.

    -   The remaining forms of the syntax, (b)--(d), are notationally
        simpler, but also less flexible, as compared to (a).

    -   one complication is that the structure of the matrix (matrices)
        D has to be determined from the value of another argument of the
        function `reStruct()`, namely, `pdClass`.

    -   By default, the argument specifies the `pdLogChol` class, which
        results in a general positive-definite matrix.

    -   To change this default choice, the argument `pdClass` needs to
        be specified explicitly, and the call to the `reStruct()`
        function has to assume the form `reStruct`(`object`, `pdClass`).

    -   LMMs for data with two or more levels of grouping, an additional
        limitation of the forms (b)--(d) of the syntax is that the
        structures of matrices D at different levels of grouping are
        forced to be the same.

-   A specific limitation of the syntax (d) for multilevel LMMs is that
    it also requires that the random-effects covariates are assumed to
    be the same at different grouping levels.

-   For some models, this limitation is irrelevant; however, this is the
    case for, e.g., LMMs with random intercepts only.

It is worth mentioning that, regardless of the form of the syntax used,
the order of specifying the grouping factors is important.

More specifically, even if the grouping factors are coded as crossed
with each other, they are effectively treated as nested, with the
nesting order corresponding to the order, in which the factors are
specified in the syntax.

In particular, the grouping factors specified later in the syntax are
nested within the factors specified earlier.

For example, according to the syntax (a) in **Table 14.1**, the factor
g2 would be treated as nested within the factor g1.

```{r "R14.5"}
methods(class = "reStruct")
reSt <- reStruct(list(g1=pdSm, g2=pdCSf))
isInitialized(reSt)
names(reSt) # Note: order g1, g2 reversed
formula(reSt) # Formulae for pdMat components


##  the structure is defined by the factors g1 and g2, 
##  with levels of g2 nested within the levels of g1. 
##  
##  Note that the function getGroupsFormula() allows 
##  two optional arguments, asList and sep. 
getGroupsFormula(reSt) # Model hierarchy

## the function Names() to the object reSt.
## The function returns the names of rows/columns for the matrices, 
## represented by the pdMat-class objects, 
## which define the reStruct-class object
Names(reSt) # Row/col names for pdMat components
View(reSt)
str(reSt)
```

### 14.3.2 Inspecting and Modifying Objects of Class reStruct

Using the function `isInitialized()`, we verify whether the object reSt
is initialized.

Given that both **pdSm** and **pdCSf** were initialized objects that
inherited from the pdMat class (see Panel R14.1), the resulting
reStruct-class object is also initialized.

```{r "R14.6"}
## (a) Listing information about positive-definite matrices 
## from a reStruct object
as.matrix(reSt) # D1, D2

coef(reSt, unconstrained = FALSE) # Unconstrained coeff. for D2, D1
coef(reSt, unconstrained = TRUE) 

## (b) Extracting individual pdMat-class components 
## from a reStruct object
reSt[["g1"]] # See pdSm in Panel R14.1b

g2.pdMat <- reSt[["g2"]] # See pdCSf in Panel R14.1c
##  confirm that the object, extracted as the g2 component of reSt, 
##  is equivalent to the pdMat-class object pdCsf
all.equal(pdCSf, g2.pdMat) # g2.pdMat and pdCSf are equal
```

```{r "R14.7"}
Zmtx1 <- model.matrix(formula(pdSm), dt1)
prmatrix(Zmtx1) # Design matrix Z1 for pdSm

Zmtx2 <- model.matrix(formula(pdCSf),dt2)
prmatrix(Zmtx2) # Design matrix Z2 for pdCSf


##  create the random-effects design matrix Z 
##  corresponding to the object reSt. 
dtz <- data.frame(dt1, dt2) # Data frame to evaluate reSt
Zmtx <- model.matrix(object = reSt, data = dtz) # Design matrix Z for reSt
prmatrix(Zmtx) # Matrix Z w/out attributes
```

-   because the object **reSt** is of class `reStruct`, the generic
    function `model.matrix()` does not dispatch its default method, but
    the `model.matrix.reStruct()` method from the `nlme` package.

-   as a result, the random-effects design matrices for the objects
    **pdSm** and **pdCSf**, which define the object **reSt**, are
    created and merged.

-   the outcome is stored in the matrix-object **Zmtx**, which is
    displayed with the use of the function `prmatrix()`.

-   in **Zmtx**, the three first columns come from the design matrix
    corresponding to the object **pdSm**, which was used to define the
    variance--covariance matrix of random effects present at the level
    of grouping corresponding to the factor g2.

-   When defining the object **reSt**, the factor was specified as the
    second one, after the factor g1 (see Panel R14.5).

```{r}
# methods(model.matrix)
# ?model.matrix
methods(class = "reStruct")
```

## 14.4 The Random Part of the Model Representation: The `lmeStruct` Class

### `lmeStruct` class is an auxiliary class

-   to compactly store the information about the random part of an LMM

-   including three elements:

    -   random effects structure
    -   correlation structure
    -   variance function.

-   objects of this class are created using the `lmeStruct()` function
    with three arguments: - reStruct (mandatory)

    -   corStruct (optional)
    -   varStruct (optional)

-   the arguments are given as objects of class:

    -   reStruct
    -   corStruct
    -   varFunc

-   function `lmeStruct()` returns a list determining the model
    components.

-   the list contains at least one component, namely, `reStruct` because
    it is mandatory.

-   an object is nevertheless created very early during the execution of
    the `lme()`-function call.

-   the importance of the `lmeStruct` class will become more apparent in
    Sect. 14.6, where we demonstrate how to extract results from an
    object containing a fit of an LMM.

```{r}
methods(class = "lmeStruct")
```

```{r}
##  the objects pdSm of class pdSymm (a general positive-definite matrix)
##  and pdCSf of class pdCompSymm (a compound-symmetry matrix)
reSt <- reStruct(list(g1 = pdSm, g2 = pdCSf)) # reStruct class
corSt <- corExp(## \rho, and \nugget
                c(0.3,        0.1),
                form = ~tx, 
                nugget = TRUE) # corStruct class
vF <- varExp(0.8, 
             ## a variance structure defined by an exponential 
             ## function of the covariate agex
             form = ~agex) # varFunc class
(lmeSt <- lmeStruct(reStruct = reSt, 
                    corStruct = corSt, 
                    varStruct = vF)) # ... created.
## Constrained coefficients...
coefs <- coef(lmeSt, 
              unconstrained = FALSE) 
(as.matrix(coefs)) # ... printed more compactly
```

## 14.5 Using the Function `lme()` to Specify and Fit Linear Mixed-Effects Models

-   the generic `lme()` function is the most frequently used function to
    fit LMMs in R.

-   to specify and fit models described in Sect. 13.2 with nested random
    effects

-   to add correlated and/or heteroscedastic within-group residual
    errors

-   in general, to define the LMM in full, we need to specify:

    -   the mean structure
    -   the random-effects structure
    -   including the grouping factors defining model hierarchy
    -   *the correlation structure*
    -   *variance function*
    -   *model frame*

```{r "14"}
methods(class = "lme")
```

![](figure/lmmur_t_14_4.png)

### fixed

-   the principal argument `fixed` is primarily used to define the mean
    structure

-   the argument can accept objects of classes `formula`, `groupedData`,
    or `lmList`

-   the corresponding method of the `lme()` function, i.e.,
    `lme.formula()`, `lme.groupedData()`, or `lme.lmList()`, is used.

    -   the most common choice for the fixed argument is a two-sided
        formula
    -   groupedData of the fixed argument only allows for mean
        structures with one (primary) covariate
    -   list of lm-class linear-model-fit objects (Sect. 5.5) for all
        levels of a grouping factor (rarely used)

### random

-   random argument is the primary argument used to define the
    random-effects structure

-   the names of the list components g1 and g2 can be omitted, with
    unnamed components, i.e., `list(pdSymm(~z1), pdDiag(~z2))`, can be
    used.

-   this simplified syntax has disadvantages, without include the
    information about the grouping factors defining the model hierarchy.

-   the information needs to be supplemented using a groupedData-class
    object in the fixed or data argument.

-   `random` argument is not specified: by default, it is assumed that
    the design matrices for the fixed and random effects are equal (Xi ≡
    Zi) and that the variance--covariance matrix for the random effects
    is defined by an object of class `pdSymm`.

That is, a general variance--covariance matrix is assumed.

### weights and correlation

-   the two arguments allow to specify the residual variance--covariance
    matrix Ri, as defined in (13.4), using the decomposition given by
    (10.8).

-   the default values for the `weights` and `correlation` arguments
    imply independent and homoscedastic conditional residual errors.

### data

additional arguments subset and na.action can be used together with data
to define the model frame

## 14.6 Extracting Information from a Model-Fit Object of Class `lme`

![](figure/lmmur_t_14_5a.png)

![](figure/lmmur_t_14_5b.png)

![](figure/lmmur_t_14_5c.png)

- the generic function `summary()` allows us to obtain general information about the fitted form of the model

  - the estimated fixed effects
  - the fitted random-effects structure
  - the estimated residual variance–covariance matrix

-  about only a specific aspect of the fitted model by extracting a specific component of the model-fit object or by applying a special function to the object

- the fixed effects b are displayed using the function `fixef()`, while the estimated
variance–covariance of the estimates `vcov()`. function `intervals()` for a model object with named components.

The possible components are the following:
* fixed (fixed effects)
* reStruct (parameters of the variance-covariance matrices of the random effects)
* corStruct (residual correlation-structure parameters)
* varFunc (residual variance-function parameters)
* sigma (scale parameter).


- the function ranef() to a model-fit object of class lme, 
the estimated random effects are displayed. By default, 
the effects at all levels of grouping are displayed. 

The levels can be selected with the help of the **level** argument. 

- estimates of the variance–covariance matrices of the random effects and residual errors, 
as well as the marginal variance–covariance matrix, are obtained using the function `getVarCov()`. 

- type="random.effects" (the default) prints out the estimates of the variance–covariance matrices of random effects,
- type="conditional" prints out the estimate of the residual variance–covariance matrix
- type="marginal" provides the estimate of the marginal variancecovariance matrix. 

- the help of the `individuals` argument, it is possible to select the group(s) of observations, 

for which the function getVarCov() should display the (residual or marginal) variance–covariance matrices.


- An alternative method to extract the variance–covariance matrix of the random effects is to use the function `VarCorr()`. 

it provides the estimates of $\sigma^ 2$ and $\sigma$ . 

The function uses three arguments: 

`x`: specifies the model-fit object

`sigma`: an optional numeric value that
indicates a multiplier for the standard deviations and assumes the value of 1 as
default

`rdig`: the last one is an optional integer value, which indicates the number of
digits (by default, 3) that areto be used to represent the correlation estimates


fitted values, residuals, and predicted values are obtained by applying the
functions fitted(), resid(), and predict(), respectively. All the functions
allow for an optional argument level, in the form of a vector of integers, which
indicates the level(s) of grouping, for which the values are to be extracted. The
levels increase from 0, i.e., the population level, to the highest level of grouping,
i.e., the level corresponding to the grouping factor, which is nested within all the
other factors.



In particular, the conditional mean values at a particular level, k say, are obtained by adding the marginal mean values and the predictors of the random effects at the grouping levels lower or equal to k. 

The conditional residuals at level k are obtained by subtracting the conditional mean
values at that level from the dependent-variable vector. 

By default, level specifies the highest level of grouping.



An important argument of the function resid() is type: 
The possible choices are type="response" (raw residuals), type="pearson" (Pearson residuals), and type="normalized" (normalized residuals). 

It is worth mentioning that the Pearson/normalized residuals are standardized/transformed based on the elements of the residual variance–covariance matrix $\pmb {\mathcal R}_i$, and not on the marginal variance–covariance matrix $\pmb {\mathcal V}_i$. 

Hence, the use of arguments type="pearson" or type="normalized" in combination with a nondefault value of level argument is not meaningful. 


This remark applies, for example, to marginal residuals obtained using level=0.


The function predict() allows for an optional argument newdata. 

It indicates a data frame for which the predictions are to be calculated. The data frame should contain all variables that were used to specify the fixed effects and the random
effects of the fitted LMM, as well as the grouping factors. 

If the argument is missing, the function will employ data used to fit the model. Consequently, it returns the fitted values corresponding to the level specified in the level argument.


Note that the function model.matrix() (Sect. 5.3.2) provides the design
matrix for the mean structure, i.e., the matrix $X_i$. 

Extracting the design matrix for the random effects, $Z_i$, from an lme-class model-fit object is difficult. 

As it requires extra programming, we do not present the required code

![](figure/lmmur_t_14.6.png)


![](figure/lmmur_t_14_7.png)

In Table 14.7, we summarize methods to extract information about the random
components of a fitted LMM. 


As mentioned in Sect. 14.4, the random part of the model, which includes the random effects structure, the residual correlation structure, and the residual variance function, is represented by an object of class lmeStruct. 

The object can be accessed by referring to the modelStruct component of the lme-class model-fit object. 

The random effects structure, as described in Sect. 14.3, is represented by an object of class reStruct, which is stored as the reStruct component of the lmeStruct-class object. 


If a correlation structure and/or a variance function were used in defining the residual variance–covariance matrix of the LMM, they are represented by objects of classes corStruct and varFunc, respectively, which are stored as components corStruct and varStruct, respectively, of the lmeStruct-class object.



## 14.7 Tests of Hypotheses About the Model Parameters


















